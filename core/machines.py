# -*- coding: utf-8 -*-
"""
Licorn foundations - http://dev.licorn.org/documentation/foundations

Copyright (C) 2005-2007 Olivier Cortès <olive@deep-ocean.net>,
Partial Copyright (C) 2006 Régis Cobrun <reg53fr@yahoo.fr>
Licensed under the terms of the GNU GPL version 2
"""

import os, crypt, sys
from time import time, strftime, gmtime, localtime

from licorn.foundations         import logging, exceptions, process, hlstr
from licorn.foundations         import pyutils, styles, fsapi
from licorn.foundations.objects import Singleton
from licorn.foundations.ltrace  import ltrace

class MachinesController(Singleton):

	machines        = None # (dictionary)
	hostname_cache  = None # (dictionary)
	init_ok         = False

	# cross-references to other common objects
	configuration = None # (LicornConfiguration)
	groups        = None # (GroupsController)

	# Filters for Select() method.
	FILTER_STANDARD = 1
	FILTER_SYSTEM   = 2

	def __init__(self, configuration):
		""" Create the machine accounts list from the underlying system.
			The arguments are None only for get (ie Export and ExportXml) """

		if MachinesController.init_ok:
			return

		if MachinesController.configuration is None:
			MachinesController.configuration = configuration

		# see Select()
		self.filter_applied = False

		MachinesController.backends = self.configuration.backends
		for bkey in MachinesController.backends.keys():
			if bkey=='prefered':
				continue
			MachinesController.backends[bkey].set_machines_controller(self)

		if MachinesController.machines is None:
			self.reload()

		MachinesController.init_ok = True
	def __getitem__(self, item):
		return MachinesController.machines[item]
	def __setitem__(self, item, value):
		MachinesController.machines[item]=value
	def keys(self):
		return MachinesController.machines.keys()
	def reload(self):
		""" Load (or reload) the data structures from the system files. """

		ltrace('machines', '> reload()')

		MachinesController.machines       = {}
		MachinesController.hostname_cache = {}

		for bkey in MachinesController.backends:
			if bkey=='prefered':
				continue
			ltrace('machines', '  reload(%s)' % bkey)
			m, c = self.backends[bkey].load_machines()

			MachinesController.machines.update(m)
			MachinesController.hostname_cache.update(c)

		ltrace('machines', '< reload()')

	def SetGroups(self, groups):
		MachinesController.groups = groups
	def WriteConf(self, mid=None):
		""" Write the machine data in appropriate system files."""

		ltrace('machines', 'saving data structures to disk.')

		if mid:
			MachinesController.backends[
				MachinesController.machines[mid]['backend']
				].save_one_machine(mid)
		else:
			for bkey in MachinesController.backends.keys():
				if bkey=='prefered':
					continue
				MachinesController.backends[bkey].save_machines()
	def Select(self, filter_string):
		""" Filter machine accounts on different criteria.
		Criteria are:
			- 'system machines': show only «system» machines (root, bin, daemon,
				apache...), not normal machine account.
			- 'normal machines': keep only «normal» machines, which includes Licorn
				administrators
			- more to come...
		"""

		raise NotImplementedError('to be rewritten')

		#
		# filter_applied is used to note if something has been selected (or
		# tried to). Without this, «get machines» on a system with no machines
		# returns all system accounts, but it should return nothing, except
		# when given --all of course. Even if nothing match the filter given
		# we must note that a filter has been applied, in order to output a
		# coherent result.
		#
		self.filter_applied    = True
		self.filtered_machines = []

		mids = MachinesController.machines.keys()
		mids.sort()

		if MachinesController.FILTER_STANDARD == filter_string:
			def keep_mid_if_not_system(mid):
				if not MachinesController.is_system_mid(mid):
					self.filtered_machines.append(mid)

			map(keep_mid_if_not_system, mids)

		elif MachinesController.FILTER_SYSTEM == filter_string:
			def keep_mid_if_system(mid):
				if MachinesController.is_system_mid(mid):
					self.filtered_machines.append(mid)

			map(keep_mid_if_system, mids)

		else:
			import re
			mid_re = re.compile("^mid=(?P<mid>\d+)")
			mid = mid_re.match(filter_string)
			if mid is not None:
				mid = int(mid.group('mid'))
				self.filtered_machines.append(mid)
	def AddMachine(self, lastname = None, firstname = None, password = None,
		primary_group=None, profile=None, skel=None, hostname=None, gecos=None,
		system = False, batch=False, force=False):
		"""Add a machine and return his/her (mid, hostname, pass)."""

		raise NotImplementedError('to be rewritten')

		logging.debug("Going to create a machine...")

		if hostname is None:
			if firstname is None or lastname is None:
				raise exceptions.BadArgumentError(
					logging.SYSU_SPECIFY_LGN_FST_LST)
			else:
				hostname_autogenerated = True
				hostname = MachinesController.make_hostname(lastname, firstname)
		else:
			hostname_autogenerated = False

		if gecos is None:
			gecos_autogenerated = True

			if firstname is None or lastname is None:
				gecos = "Compte %s" % hostname
			else:
				gecos = "%s %s" % (firstname, lastname.upper())
		else:
			gecos_autogenerated = False

			if firstname and lastname:
				raise exceptions.BadArgumentError(
					logging.SYSU_SPECIFY_LF_OR_GECOS)
			# else: all is OK, we have a hostname and a GECOS field

		# FIXME: in rare cases, we could discard some machine data ; e.g. if we got
		# a GECOS and *only* a firstname, the firstname will be discarded. We
		# should display a warning, or ask the admin.

		if not hlstr.cregex['hostname'].match(hostname):
			if hostname_autogenerated:
				raise exceptions.LicornRuntimeError(
					"Can't build a valid hostname (%s) with the " \
					"firstname/lastname (%s/%s) you provided." % (
					hostname, firstname, lastname) )
			else:
				raise exceptions.BadArgumentError(
					logging.SYSU_MALFORMED_LOGIN % (
						hostname, styles.stylize(styles.ST_REGEX,
						hlstr.regex['hostname'])))

		if not hostname_autogenerated and \
			len(hostname) > MachinesController.configuration.machines.hostname_maxlenght:
			raise exceptions.LicornRuntimeError(
				"Login too long (%d characters," \
				" but must be shorter or equal than %d)." % (
					len(hostname),
					MachinesController.configuration.machines.hostname_maxlenght) )

		if not hlstr.cregex['description'].match(gecos):
			if gecos_autogenerated:
				raise exceptions.LicornRuntimeError(
					"Can't build a valid GECOS (%s) with the" \
					" firstname/lastname (%s/%s) or hostname you provided." % (
						gecos, firstname, lastname) )
			else:
				raise exceptions.BadArgumentError(
					logging.SYSU_MALFORMED_GECOS % (
						gecos, styles.stylize(styles.ST_REGEX,
						hlstr.regex['description']) ) )

		if primary_group:
			pg_gid = MachinesController.groups.name_to_gid(primary_group)

		if skel and skel not in MachinesController.configuration.machines.skels:
			raise exceptions.BadArgumentError(
				"The skel you specified doesn't exist on this system." \
				" Valid skels are: %s." % \
					MachinesController.configuration.machines.skels)

		tmp_machine_dict = {}

		# Verify existance of machine
		for mid in MachinesController.machines:
			if MachinesController.machines[mid]['hostname'] == hostname:
				raise exceptions.AlreadyExistsException, \
					"A machine named « %s » already exists !" % hostname
				#
				# TODO ? continue creation if not a system account, to verify
				# everything is OK in the homedir, in the ACLs, etc.
				#
				# FIXME: verify everything besides the hostname before shouting
				# the machine already exists.
		#
		# Due to a bug of addmachine/delmachine perl script, we must check that there
		# is no group which the same name than the hostname. There should not
		# already be a system group with the same name (we are just going to
		# create it...), but it could be a system inconsistency, so go on to
		# recover from it.
		#
		# {add,del}machine logic is:
		#	- a system account must always have a system group as primary group,
		# 		else if will be «nogroup» if not specified.
		#   - when deleting a system account, a corresponding system group will
		#		be deleted if existing.
		#	- no restrictions for a standard account
		#
		# the bug is that in case 2, delmachine will delete the group even if this
		#  is a standard group (which is bad). This could happen with:
		#	addgroup toto
		#	addmachine --system toto --ingroup root
		#	delmachine --system toto
		#	(group toto is deleted but it shouldn't be ! And it is deleted
		#	without *any* message !!)
		#
		for gid in MachinesController.groups.groups:
			if MachinesController.groups.groups[gid]['name'] == hostname and not force:
				raise exceptions.UpstreamBugException, \
					"A group named `%s' exists on the system," \
					" this could eventually conflict in Debian/Ubuntu system" \
					" tools. Please choose another machine's hostname, or use " \
					"--force argument if you really want to add this machine " \
					"on the system." % hostname

		if password is None:
			# TODO: call cracklib2 to verify passwd strenght.
			password = hlstr.generate_password(
				MachinesController.configuration.mAutoPasswdSize)
			logging.notice(logging.SYSU_AUTOGEN_PASSWD % (
				styles.stylize(styles.ST_LOGIN, hostname),
				styles.stylize(styles.ST_SECRET, password) ) )

		groups_to_add_machine_to = []

		skel_to_apply = "/etc/skel"
		# 3 cases:
		if profile is not None:
			# Apply the profile after having created the home dir.
			try:
				tmp_machine_dict['hostnameShell'] = \
					MachinesController.profiles.profiles[profile]['shell']
				tmp_machine_dict['gidNumber'] = \
					MachinesController.groups.name_to_gid(
					MachinesController.profiles.profiles[profile]['primary_group'])
				# fix #58.
				tmp_machine_dict['homeDirectory'] = ("%s/%s" % (
					MachinesController.configuration.machines.base_path, hostname))

				if MachinesController.profiles.profiles[profile]['groups'] != []:
					groups_to_add_machine_to = \
						MachinesController.profiles.profiles[profile]['groups']

					# don't directly add the machine to the groups. prepare the
					# groups to use the Licorn API later, to create the groups
					# symlinks while adding machine to them.
					#
					# machineadd_options.append("-G " + ",".join(
					# MachinesController.profiles.profiles[profile]['groups']))

				if skel is None:
					skel_to_apply = \
						MachinesController.profiles.profiles[profile]['skel_dir']
			except KeyError, e:
				# fix #292
				raise exceptions.LicornRuntimeError(
					"The profile %s does not exist on this system (was: %s) !" \
						% (profile, e))
		elif primary_group is not None:

			tmp_machine_dict['gidNumber']     = pg_gid
			tmp_machine_dict['hostnameShell']    = \
				MachinesController.configuration.machines.default_shell
			tmp_machine_dict['homeDirectory'] = "%s/%s" % (
				MachinesController.configuration.machines.base_path, hostname)

			# FIXME: use is_valid_skel() ?
			if skel is None and \
				os.path.isdir(
					MachinesController.groups.groups[pg_gid]['groupSkel']):
				skel_to_apply = \
					MachinesController.groups.groups[pg_gid]['groupSkel']

		else:
			tmp_machine_dict['gidNumber'] = \
				MachinesController.configuration.machines.default_gid
			tmp_machine_dict['hostnameShell'] = \
				MachinesController.configuration.machines.default_shell
			tmp_machine_dict['homeDirectory'] = "%s/%s" % (
				MachinesController.configuration.machines.base_path, hostname)
			# if skel is None, system default skel will be applied

		# FIXME: is this necessary here ? not done before ?
		if skel is not None:
			skel_to_apply = skel

		if system:
			mid = pyutils.next_free(self.machines.keys(),
				self.configuration.machines.system_mid_min,
				self.configuration.machines.system_mid_max)
		else:
			mid = pyutils.next_free(self.machines.keys(),
				self.configuration.machines.mid_min,
				self.configuration.machines.mid_max)

		tmp_machine_dict['machinePassword'] = \
			MachinesController.backends['prefered'].compute_password(password)

		tmp_machine_dict['shadowLastChange'] = str(int(time()/86400))

		# create home directory and apply skel
		if not os.path.exists(tmp_machine_dict['homeDirectory']):
			import shutil
			# copytree automatically creates tmp_machine_dict['homeDirectory']
			shutil.copytree(skel_to_apply, tmp_machine_dict['homeDirectory'])
		#
		# else: the home directory already exists, we don't overwrite it
		#

		tmp_machine_dict['midNumber']      = mid
		tmp_machine_dict['gecos']          = gecos
		tmp_machine_dict['hostname']       = hostname
		# prepare the groups cache.
		tmp_machine_dict['groups']         = []
		tmp_machine_dict['shadowInactive'] = ''
		tmp_machine_dict['shadowWarning']  = 7
		tmp_machine_dict['shadowExpire']   = ''
		tmp_machine_dict['shadowMin']      = 0
		tmp_machine_dict['shadowMax']      = 99999
		tmp_machine_dict['shadowFlag']     = ''
		tmp_machine_dict['backend']        = \
			MachinesController.backends['unix'].name if system else \
			MachinesController.backends['prefered'].name

		# Add machine in internal list and in the cache
		MachinesController.machines[mid]         = tmp_machine_dict
		MachinesController.hostname_cache[hostname] = mid

		#
		# we can't skip the WriteConf(), because this would break Samba stuff,
		# and AddMachinesInGroup stuff too:
		# Samba needs Unix account to be present in /etc/* before creating the
		# Samba account. We thus can't delay the WriteConf() call, even if we
		# are in batch / import machines mode. This is roughly the same with group
		# Additions: the machine must be present, prior to additions.
		#
		# DO NOT UNCOMMENT -- if not batch:
		MachinesController.machines[mid]['action'] = 'create'
		MachinesController.backends[
			MachinesController.machines[mid]['backend']
			].save_machine(mid)

		# Samba: add Samba machine account.
		# TODO: put this into a module.
		try:
			sys.stderr.write(process.execute(['smbpasswd', '-a', hostname, '-s'],
				'%s\n%s\n' % (password, password),)[1])
		except (IOError, OSError), e:
			if e.errno not in (2, 32):
				raise e

		if groups_to_add_machine_to != []:

			logging.debug("machine %s is going to be added to %s." % (
				styles.stylize(styles.ST_LOGIN, hostname), groups_to_add_machine_to))

			for group in groups_to_add_machine_to:
				MachinesController.groups.AddMachinesInGroup(group, [hostname])

		# Set quota
		if profile is not None:
			try:
				pass
				#os.popen2( [ 'quotatool', '-u', str(mid), '-b', MachinesController.configuration.defaults.quota_device, '-l' '%sMB' % MachinesController.profiles.profiles[profile]['quota'] ] )[1].read()
				#logging.warning("quotas are disabled !")
				# XXX: Quotatool can return 2 without apparent reason
				# (the quota is etablished) !
			except exceptions.LicornException, e:
				logging.warning( "ROLLBACK create machine because '%s'." % str(e))
				self.DeleteMachine(hostname, True)
				return (False, False, False)

		self.CheckMachines([ hostname ], batch = True)

		logging.info(logging.SYSU_CREATED_USER % (
			styles.stylize(styles.ST_LOGIN, hostname),
			styles.stylize(styles.ST_UGID, mid)))

		return (mid, hostname, password)
	def DeleteMachine(self, hostname=None, no_archive=False, mid=None, batch=False):
		""" Delete a machine """

		raise NotImplementedError('to be rewritten')

		if hostname is None and mid is None:
			raise exceptions.BadArgumentError(logging.SYSU_SPECIFY_LGN_OR_UID)

		if mid is None:
			mid = MachinesController.hostname_to_mid(hostname)

		elif hostname is None:
			# «hostname» is needed for delmachine system command.
			hostname = MachinesController.machines[mid]["hostname"]

		ltrace('machines', "| DeleteMachine() %s(%s), groups %s." % (
			hostname, str(mid), MachinesController.machines[mid]['groups']) )

		# Delete machine from his groups
		# '[:]' to fix #14, see
		# http://docs.python.org/tut/node6.html#SECTION006200000000000000000
		for group in MachinesController.machines[mid]['groups'].copy():
			MachinesController.groups.RemoveMachinesFromGroup(group, [ hostname ],
				batch=True)

		try:
			# samba stuff
			sys.stderr.write(process.execute(['smbpasswd', '-x', hostname])[1])
		except (IOError, OSError), e:
			if e.errno not in (2, 32):
				raise e

		# keep the homedir path, to backup it if requested.
		homedir = MachinesController.machines[mid]["homeDirectory"]

		# keep the backend, to notice the deletion
		backend = MachinesController.machines[mid]['backend']

		# Delete machine from machines list
		del(MachinesController.hostname_cache[hostname])
		del(MachinesController.machines[mid])
		logging.info(logging.SYSU_DELETED_USER % \
			styles.stylize(styles.ST_LOGIN, hostname))

		# TODO: try/except and reload the machine if unable to delete it
		# delete the machine in the backend after deleting it locally, else
		# Unix backend will not know what to delete (this is quite a hack).
		MachinesController.backends[backend].delete_machine(hostname)

		# machine is now wiped out from the system.
		# Last thing to do is to delete or archive the HOME dir.

		if no_archive:
			import shutil
			try:
				shutil.rmtree(homedir)
			except OSError, e:
				logging.warning("Problem deleting home dir %s (was: %s)" % (
					styles.stylize(styles.ST_PATH, homedir), e))

		else:
			MachinesController.configuration.CheckBaseDirs(minimal = True,
				batch = True)
			machine_archive_dir = "%s/%s.deleted.%s" % (
				MachinesController.configuration.home_archive_dir,
				hostname, strftime("%Y%m%d-%H%M%S", gmtime()))
			try:
				os.rename(homedir, machine_archive_dir)
				logging.info(logging.SYSU_ARCHIVED_USER % (homedir,
					styles.stylize(styles.ST_PATH, machine_archive_dir)))
			except OSError, e:
				if e.errno == 2:
					logging.warning(
						"Home dir %s doesn't exist, thus not archived." % \
							styles.stylize(styles.ST_PATH, homedir))
				else:
					raise e
	def ChangeMachinePassword(self, hostname, password = None, display = False):
		""" Change the password of a machine
		"""
		if hostname is None:
			raise exceptions.BadArgumentError(logging.SYSU_SPECIFY_LOGIN)
		if password is None:
			password = hlstr.generate_password(
				MachinesController.configuration.mAutoPasswdSize)
		elif password == "":
			logging.warning(logging.SYSU_SET_EMPTY_PASSWD % \
				styles.stylize(styles.ST_LOGIN, hostname))
			#
			# SECURITY concern: if password is empty, shouldn't we
			# automatically remove machine from remotessh ?
			#

		mid = MachinesController.hostname_to_mid(hostname)

		MachinesController.machines[mid]['machinePassword'] = \
		MachinesController.backends[
			MachinesController.machines[mid]['backend']
			].compute_password(password)

		# 3600*24 to have the number of days since epoch (fixes #57).
		MachinesController.machines[mid]['shadowLastChange'] = str(
			int(time()/86400) )

		MachinesController.machines[mid]['action'] = 'update'
		MachinesController.backends[
			MachinesController.machines[mid]['backend']
			].save_machine(mid)

		if display:
			logging.notice("Set machine %s's password to %s." % (
				styles.stylize(styles.ST_NAME, hostname),
				styles.stylize(styles.ST_IMPORTANT, password)))
		else:
			logging.info('Changed password for machine %s.' % \
				styles.stylize(styles.ST_NAME, hostname))

		try:
			# samba stuff
			sys.stderr.write(process.execute(['smbpasswd', hostname, '-s'],
				"%s\n%s\n" % (password, password))[1])
		except (IOError, OSError), e:
			if e.errno != 32:
				raise e
	def ChangeMachineGecos(self, hostname, gecos = ""):
		""" Change the gecos of a machine
		"""
		if hostname is None:
			raise exceptions.BadArgumentError(logging.SYSU_SPECIFY_LOGIN)

		if not hlstr.cregex['description'].match(gecos):
			raise exceptions.BadArgumentError(logging.SYSU_MALFORMED_GECOS % (
				gecos,
				styles.stylize(styles.ST_REGEX, hlstr.regex['description'])))

		mid = MachinesController.hostname_to_mid(hostname)
		MachinesController.machines[mid]['gecos'] = gecos

		MachinesController.machines[mid]['action'] = 'update'
		MachinesController.backends[
			MachinesController.machines[mid]['backend']
			].save_machine(mid)
	def ChangeMachineShell(self, hostname, shell = ""):
		""" Change the shell of a machine. """
		if hostname is None:
			raise exceptions.BadArgumentError(logging.SYSU_SPECIFY_LOGIN)

		mid = MachinesController.hostname_to_mid(hostname)

		if shell not in MachinesController.configuration.machines.shells:
			raise exceptions.LicornRuntimeError(
				"Invalid shell ! valid shells are %s." % \
					MachinesController.configuration.machines.shells)

		MachinesController.machines[mid]['hostnameShell'] = shell

		MachinesController.machines[mid]['action'] = 'update'
		MachinesController.backends[
			MachinesController.machines[mid]['backend']
			].save_machine(mid)
	def LockAccount(self, hostname, lock = True):
		"""(Un)Lock a machine account."""
		if hostname is None:
			raise exceptions.BadArgumentError(logging.SYSU_SPECIFY_LOGIN)

		#
		# TODO: lock the shell (not just the password), else SSH connections
		# with private/public keys could still be usable. As an alternative,
		# we could just remove machine from remotessh group, which seems to be
		# a Licorn prerequisite.
		#

		# update internal data structures.
		mid = MachinesController.hostname_to_mid(hostname)

		if lock:
			MachinesController.machines[mid]['machinePassword'] = '!' + \
				MachinesController.machines[mid]['machinePassword']
			logging.info('Locked machine account %s.' % \
				styles.stylize(styles.ST_LOGIN, hostname))
		else:
			MachinesController.machines[mid]['machinePassword'] = \
				MachinesController.machines[mid]['machinePassword'][1:]
			logging.info('Unlocked machine account %s.' % \
				styles.stylize(styles.ST_LOGIN, hostname))
		MachinesController.machines[mid]['locked'] = lock


		MachinesController.machines[mid]['action'] = 'update'
		MachinesController.backends[
			MachinesController.machines[mid]['backend']
			].save_machine(mid)
	def ExportCLI( self, long_output = False):
		""" Export the machine accounts list to human readable («passwd») form.
		"""
		if self.filter_applied:
			mids = self.filtered_machines
		else:
			mids = MachinesController.machines.keys()

		mids.sort()

		def build_cli_output_machine_data(mid,
			machines=MachinesController.machines):

			account = [	styles.stylize(styles.ST_SPECIAL \
							if machines[mid]['floating'] else styles.ST_NAME,
							machines[mid]['hostname']),
						styles.stylize(styles.ST_OK, 'Online') \
								if machines[mid]['status'] \
								else styles.stylize(styles.ST_BAD, 'Offline'),
						'floating' if machines[mid]['floating'] \
								else 'fixed',
						str(mid),
						str(machines[mid]['ether']),
						styles.stylize(styles.ST_ATTR,
							strftime('%Y-%d-%m %H:%M:%S',
							localtime(float(machines[mid]['expiry'])))) \
							if machines[mid]['expiry'] else '',
						]
			return '/'.join(account)

		data = '\n'.join(map(build_cli_output_machine_data, mids)) + '\n'

		return data
	def ExportCSV( self, long_output = False):
		"""Export the machine accounts list to CSV."""

		raise NotImplementedError('to be rewritten')

		if self.filter_applied:
			mids = self.filtered_machines
		else:
			mids = MachinesController.machines.keys()

		mids.sort()

		def build_csv_output_licorn(mid):
			return ';'.join(
				[	MachinesController.machines[mid]['gecos'],
					MachinesController.machines[mid]['hostname'],
					str(MachinesController.machines[mid]['gidNumber']),
					','.join(MachinesController.machines[mid]['groups']) ]
				)

		data = '\n'.join(map(build_csv_output_licorn, mids)) +'\n'

		return data
	def ExportXML( self, long_output = False):
		""" Export the machine accounts list to XML. """

		raise NotImplementedError('to be rewritten')

		if self.filter_applied:
			mids = self.filtered_machines
		else:
			mids = MachinesController.machines.keys()

		mids.sort()

		def build_xml_output_machine_data(mid):
			data = '''
	<machine>
		<hostname>%s</hostname>
		<mid>%d</mid>
		<gid>%d</gid>
		<gecos>%s</gecos>
		<homeDirectory>%s</homeDirectory>
		<hostnameShell>%s</hostnameShell>\n''' % (
					MachinesController.machines[mid]['hostname'],
					mid,
					MachinesController.machines[mid]['gidNumber'],
					MachinesController.machines[mid]['gecos'],
					MachinesController.machines[mid]['homeDirectory'],
					MachinesController.machines[mid]['hostnameShell']
				)
			if long_output:
				data += "		<groups>%s</groups>\n" % \
					','.join(MachinesController.machines[mid]['groups'])

			return data + "	</machine>"

		data = "<?xml version='1.0' encoding=\"UTF-8\"?>\n<machines-list>\n" \
			+ '\n'.join(map(build_xml_output_machine_data, mids)) \
			+ "\n</machines-list>\n"

		return data

	@staticmethod
	def machine_exists(mid = None, hostname = None):
		if mid:
			return MachinesController.machines.has_key(mid)
		if hostname:
			return MachinesController.hostname_cache.has_key(hostname)

		raise exceptions.BadArgumentError(
			"You must specify a MID or a hostname to test existence of.")
	@staticmethod
	def hostname_to_mid(hostname):
		""" Return the mid of the machine 'hostname'. """
		try:
			# use the cache, Luke !
			return MachinesController.hostname_cache[hostname]
		except KeyError:
			try:
				int(hostname)
				logging.warning("You passed an mid to hostname_to_mid():"
					" %d (guess its hostname is « %s » )." % (
						hostname, MachinesController.machines[hostname]['hostname']))
			except ValueError:
				pass

			raise exceptions.LicornRuntimeException(
				_('''machine %s doesn't exist.''') % hostname)
	@staticmethod
	def make_hostname(inputhostname=None):
		""" Make a valid hostname from what we're given. """

		if inputhostname is None:
			raise exceptions.BadArgumentError(
				_('''You must pass a hostname to verify!'''))

		# use provided hostname and verify it.
		hostname = hlstr.validate_name(str(inputhostname),
			maxlenght = MachinesController.configuration.machines.hostname_maxlenght)

		if not hlstr.cregex['hostname'].match(hostname):
			raise exceptions.LicornRuntimeError(
				_('''Can't build a valid hostname (got %s, which doesn't'''
				''' verify %s)''') % (
					inputhostname, hlstr.regex['hostname']))

		return hostname
