# -*- coding: utf-8 -*-
"""
Licorn foundations: classes - http://docs.licorn.org/

:copyright:
	* 2005-2010 Olivier Cortès <olive@deep-ocean.net>
	* partial 2010 RobinLucbernet <robinlucbernet@gmail.com>

:license: GNU GPL version 2

"""

import sys, os, time, tempfile, weakref, types, stat, errno

from threading   import current_thread
from collections import deque

# Licorn foundations imports.
import exceptions, logging
import pyutils, fsapi, readers
from styles    import *
from ltrace    import *
from ltraces   import *
from base      import Enumeration

class ConfigFile(Enumeration):
	""" A Configuration file class which handles adds/removes cleverly and loads
		from one of our readers, provided the reader returns a dict.

		.. versionadded:: 1.3
			this class was created by Robin in the 1.3 development cycle.
	"""

	def __init__(self, filename, name=None, reader=readers.generic_reader,
		separator=None, caller=None):
		assert ltrace(TRACE_OBJECTS, '| ConfigFile.__init__(filename=%s, name=%s)' %
			(filename, name))
		Enumeration.__init__(self, name=name if name else filename)

		self._filename = filename

		if not os.path.exists(filename):
			fsapi.touch(filename)

		self._separator = separator
		self._reader = reader

		self.__caller = caller

		self.reload()
	@property
	def _caller(self):
		""" read-only property, returning the name of the caller (as a string).
			The caller can be a thread, a module, another Licorn® object
			instance, whatever.

			If it is None (not set at creation of the current :class:`ConfigFile`)
			instance, the name of the current thread will be returned.
		"""
		if self.__caller is None:
			return current_thread()
		else:
			return self.__caller
	def __str__(self):
		data = ''

		for key, value in self.iteritems():
			if hasattr(value, '__iter__'):
				for v in value:
					data += '%s%s%s\n' % (key, self._separator if
						self._separator is not None else '',
						v if v is not None else '')
			else:
				data += '%s%s%s\n' % (key, self._separator  if
						self._separator is not None else '',
						value if value is not None else '')

		return data
	def reload(self, filename=None):
		""" load or reload the data, eventually from another configuration
			file. Lock the file while reading it. """

		if filename is None:
			filename = self._filename

		with FileLock(self, filename):
			if self._separator is None:
				func = self._reader(filename)

			else:
				func = self._reader(filename, self._separator)

			for key, value in func.iteritems():
				if hasattr(value, '__iter__'):
					for v in value:
						pyutils.add_or_dupe_enumeration(self, key, v)
				else:
					self[key] = value
	def backup_and_save(self, batch=False, auto_answer=None):
		""" do the "backup and save" operation in one method call, which wraps
			logging and user questioning, to avoid code duplication when this
			functionnality is required (and it is *a lot*)."""

		if batch or logging.ask_for_repair(_(u'{0}: system file {1} must be '
			'modified for the configuration to be complete. Do it?').format(
						stylize(ST_NAME, self._caller),
						stylize(ST_PATH, self._filename)),
					auto_answer=auto_answer):

			self.backup()
			self.save()

			logging.notice(_(u'{0}: altered configuration file {1}.').format(
				stylize(ST_NAME, self._caller), stylize(ST_PATH, self._filename)))

		else:
			raise exceptions.LicornModuleError(_(u'{0}: configuration file {1} '
				'must be altered to continue.').format(self._caller, self._filename))
	def backup(self):
		return fsapi.backup_file(self._filename)
	def save(self, filename=None):
		""" Write the configuration file contents back to the disk. """

		if filename is None:
			filename = self._filename

		assert ltrace(TRACE_OBJECTS, '| ConfigFile.save(%s)' % filename)

		data = ('#-------------------------------------------------------\n'
				'# %s configuration file generated by Licorn®. \n'
				'#-------------------------------------------------------\n\n'
					% self.name) + str(self)

		with FileLock(self, filename):
			# old method, the hard and insecure way.
			#open(filename, 'w').write(data)

			# For /etc/passwd (and others),
			# we need to make this a little more atomic
			ftempp, fpathp = tempfile.mkstemp(dir=os.path.dirname(filename))
			os.write(ftempp, data)

			# FIXME: implement these ch* calls properly, with dynamic for
			# the permissions...
			os.fchmod(ftempp, 0644)

			# TODO: we cannot give everything to root inconditionnaly.
			# we should get the original UID/GID of the previous file,
			# to reapply them on the new.
			#os.fchown(ftempp, 0, 0)

			os.close(ftempp)

			# FIXME: implement this one too...
			#self.__hint_pwd += 1

			try:
				os.rename(fpathp, filename)

			except (IOError, OSError), e:
				if e.errno in (errno.EPERM, errno.EACCES):
					# FIXME: we are root, EPERM/EACCES is not an option. The
					# file is probably made `chattr +i` until #558 is fixed.
					# In that case, we will assume the configuration is OK
					# and we should not crash at all. Informing the sysadmin
					# about the situation is fine, though: he will not forget
					# the file is flagged.
					if fsapi.has_flags(filename, [ stat.SF_IMMUTABLE ]):
						logging.warning(_(u'{0}: File {1} is protected by '
							u'the {2} flag, we cannot alter it. Hope this '
							u'is intended, because we are continuing like '
							u'if it was modified but it is NOT.').format(
								stylize(ST_IMPORTANT, _(u'IMPORTANT')),
								stylize(ST_PATH, filename),
								stylize(ST_ATTR, 'IMMUTABLE')
								)
							)
				else:
					raise
	def has(self, key, value=None):
		""" Return true or false if config is already in. """

		if key in self.keys() and (value is None or value in self[key]):
			assert ltrace(TRACE_OBJECTS, "%s: '%s %s' detected" % (
				self.name, key, self[key]))
			return True
		return False
	def add(self, key, value, dont_check=False, replace=False):
		""" TODO. """
		if replace:
			self[key] = value
			logging.progress('%s: %s configuration key %s with value %s' % (
				stylize(ST_PATH, self.name), stylize(ST_OK, "modified"),
				stylize(ST_NAME, key), stylize(ST_NAME, value)))
			assert ltrace(TRACE_OBJECTS, "%s: overwritten '%s %s'" % (
				self.name, key, value))
		elif dont_check or not self.has(key, value):
			pyutils.add_or_dupe_enumeration(self, key, value)
			logging.progress('%s: %s configuration key %s with value %s' % (
				stylize(ST_PATH, self.name), stylize(ST_OK, "added"),
				stylize(ST_NAME, key), stylize(ST_NAME, value)))
			assert ltrace(TRACE_OBJECTS, "%s: added '%s %s'" % (
					self.name, key, value))
	def remove(self, key, value=None, dont_check=False):
		""" TODO. """

		if dont_check or self.has(key, value):
			if hasattr(self[key], '__iter__'):
				self[key].remove(value)
				if self[key] in ('', []):
					del self[key]
			else:
				del self[key]
			logging.progress('%s: %s configuration key %s with value %s' % (
				stylize(ST_PATH, self.name), stylize(ST_BAD, "removed"),
				stylize(ST_NAME, key), stylize(ST_NAME, value)))
			assert ltrace(TRACE_OBJECTS, "%s: removed '%s%s'" % (
				self.name, key, ' ' + value if value else ''))
class FileLock:
	"""
		This FileLock class is a reimplementation of basic locks with files.
		This is needed to be compatible with adduser/login binaries, which
		use /etc/{passwd,group}.lock to signify that the system files are locked.

	"""

	def __init__(self, configuration, filename, waitmax=10, verbose=True):

		# TODO: don't blow up if user_dir isn't set (which is the case for daemon user)

		self.pretty_name = str(self.__class__).rsplit('.', 1)[1]

		if filename is None :
			raise exceptions.LicornRuntimeError("please specify a file to lock")

		self.filename = filename + '.lock'
		self.lockname = filename.rsplit('/', 1)[1]

		assert ltrace(TRACE_OBJECTS, '%s: new instance with %s.' % (self.pretty_name,
			stylize(ST_PATH, self.filename)))

		self.waitmax = waitmax
		self.wait    = waitmax
		self.verbose = verbose

	# Make FileLock be usable as a context manager.
	def __enter__(self):
		self.acquire()
	def __exit__(self, type, value, tb):
		self.release()

	def acquire(self):
		"""Acquire a lock, i.e. create $file.lock."""
		assert ltrace(TRACE_OBJECTS, '%s: pseudo-locking %s.' % (
						self.pretty_name, stylize(ST_PATH, self.lockname)))

		try:
			self.wait = self.waitmax

			while os.path.exists(self.filename) and self.wait >= 0:
				if self.verbose:
					sys.stderr.write("\r %s waiting %d second(s) for %s lock to be released… "
						% (stylize(ST_NOTICE, '*'), self.wait, self.lockname))
					sys.stderr.flush()
				self.wait = self.wait - 1
				time.sleep(1)

			if self.wait <= 0:
				sys.stderr.write("\n")
				raise IOError, "%s lockfile still present, can't acquire lock after timeout !" % self.lockname

			else:
				try:
					open(self.filename, "w")

				except (IOError, OSError):
					raise IOError, "Can't create lockfile %s." % self.filename

		except KeyboardInterrupt:
			sys.stderr.write("\n")
			raise

		assert ltrace(TRACE_OBJECTS, '%s: successfully locked %s.' % (
					self.pretty_name, stylize(ST_PATH, self.filename)))
	def release(self):
		"""Free the lock by removing the associated lockfile."""

		assert ltrace(TRACE_OBJECTS, '%s: removing lock on %s.' % (
						self.pretty_name, stylize(ST_PATH, self.lockname)))

		try:
			os.unlink(self.filename)

		except (IOError, OSError), e:
			if e.errno != errno.ENOENT:
				raise OSError, "can't remove lockfile %s." % self.filename

		assert ltrace(TRACE_OBJECTS, '%s: successfully unlocked %s.' % (
						self.pretty_name, stylize(ST_PATH, self.filename)))

	def is_locked(self):
		"""Tell if a file is currently locked by looking if the associated lock
		is present."""
		return os.path.exists(self.filename)

	# old style primitive names
	Lock     = acquire
	Unlock   = release
	IsLocked = is_locked
	locked   = is_locked
class StateMachine:
	"""
		A Finite state machine design pattern.
		Found at http://www.ibm.com/developerworks/library/l-python-state.html , thanks to David Mertz.
	"""
	def __init__(self):
		self.handlers = {}
		self.startState = None
		self.endStates = []

	def add_state(self, name, handler, end_state = False):
		self.handlers[name] = handler
		if end_state:
			 self.endStates.append(name)

	def set_start(self, name):
		self.startState = name

	def run(self, data):
		try:
			 handler = self.handlers[self.startState]
		except:
			 raise exceptions.LicornRuntimeError("LSM: must call .set_start() before .run()")

		if not self.endStates:
				 raise exceptions.LicornRuntimeError("LSM: at least one state must be an end_state.")

		while True:
			(newState, data) = handler(data)
			if newState in self.endStates:
				break
			else:
				handler = self.handlers[newState]
class SharedResource(object):
	""" Make the current object be usable by many threads, and keep
		reference of threads working on it.

		This is kind of an inverse-semaphore (any number of workers can use
		the current object).

		offers a busy() method which returns True if one worker or more
		currently owns the object.
		"""
	_lpickle_ = {
			'to_drop': [ '_SharedResource__workers' ]
		}

	def __init__(self, **kwargs):
		# usage of a `deque` avoids the need of a surrounding RLock()
		self.__workers = deque(maxlen=kwargs.pop('limit', None))
	@property
	def workers(self):
		return self.__workers
	def __enter__(self):
		self.__workers.append(current_thread())
		#print '>> ACQUIRED', self.name, 'BY', self.__workers
	acquire = __enter__
	def __exit__(self, etype=None, value=None, traceback=None):
		""" TODO: use arguments... """
		self.__workers.remove(current_thread())
		#print '>> RELEASED', self.name, 'REMAINS', self.__workers
	release = __exit__
	def busy(self):
		if current_thread() in self.__workers:
			return len(self.__workers) > 1
		else:
			return len(self.__workers) > 0
class PicklableObject(object):
	""" Currently, this serves only as base for `CoreModule`, because
		`CoreUnitObjects` derivatives have too much specialties to be
		refactored into this class.

		Worth reads:

		* http://rhettinger.wordpress.com/2011/05/26/super-considered-super/
		* http://stackoverflow.com/questions/576169/understanding-python-super-and-init-methods
		* http://stackoverflow.com/questions/222877/how-to-use-super-in-python
		* http://fuhm.net/super-harmful/ : this one points best practices that
			are just "required" practices to me...
		* http://www.artima.com/weblogs/viewpost.jsp?thread=236275
		* http://stackoverflow.com/questions/2922628/how-to-pickle-and-unpickle-objects-with-self-references-and-from-a-class-with-sl

		Descriptors worth read:

		* http://users.rcn.com/python/download/Descriptor.htm
	"""

	_lpickle_ = {
			# should pickle drop '_*' attributes ?
			# this is done last, in __getstate__(), in case some private
			# attributes need to be converted first.
			#
			# NOTE: there is a problem when a subclass wants to keep some `__*`
			# attributes, all higher classes need to drop them by their name,
			# which is not very practical. This will eventually be resolved
			# some day; for now, higher classes have a small number of
			# attributes, thus we have listed them by hand to be dropped and
			# everything is fine.
			'drop__' : True,
		}

	def _lpickle_merge_conf(self):
		try:
			return self.__class__.lpickle_merged_conf

		except AttributeError:
			self.__class__.lpickle_merged_conf = pyutils.merge_dicts_of_lists(*[
								cls._lpickle_
									# mro[:-1] avoids taking 'object' in the loop
									for cls in reversed(self.__class__.__mro__[:-1]) if hasattr(cls, '_lpickle_')
							], unique=True)
			return self.__class__.lpickle_merged_conf
	def __getstate__(self):
		pickle_conf = self._lpickle_merge_conf()
		cur_state   = self.__dict__.copy()

		#print '>>> PKL', self.name, self.__class__
		#print '>>>', cur_state

		for special in pickle_conf.get('to_drop', ()):
			try:
				del cur_state[special]
				#print '>>> drop', special

			except KeyError: pass

		#print '>>>', cur_state

		for special in pickle_conf.get('by_name', ()):
			try:
				cur_state[special + '_pickle_name_'] = getattr(self, special).name
				del cur_state[special]
				#print '>>> by_name', special

			except (AttributeError, KeyError):
				# Either "getattr(self, special)" or "del cur_state[special]"
				# did not work. This is harmless in any case.
				pass

		if pickle_conf.get('drop__', True):
			# NOTE: don't use 'for key in cur_state:', it will break for
			# 'dictionnary changed during iteration.', and you will not
			# notice it because Pyro is so weak in forwarding pickle exceptions.
			for key in cur_state.keys():
				if key.startswith('_'):
					try:
						del cur_state[key]
						#print '>>> drop', key

					except: pass

		# we still need to drop unpicklable types.
		for key, value in cur_state.items():
			#print '>> PKL', key, value, type(value), type(value) == types.FunctionType
			if isinstance(value, weakref.ReferenceType) or (
										hasattr(value, '__call__') and
										(hasattr(value, 'is_callback') or
										hasattr(value, 'is_handler'))):
				try:
					del cur_state[key]
					#print '>>> drop', key

				except: pass

		cur_state['_pickled'] = True

		return cur_state
	def __setstate__(self, data):
		pickle_conf = self._lpickle_merge_conf()

		# CURRENT: use conf or guess from key.endswith() ?

		for special in pickle_conf.get('by_name', ()):
			try:
				# TODO: use data.pop()
				special_value = data.get(special + '_pickle_name_')

			except KeyError:
				pass

			else:
				try:
					setattr(self, special_value, getattr(LMC, special_value))

				except (NameError, AttributeError):
					pass

		self.__dict__.update(data)
