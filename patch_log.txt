Massive patch for version 1.3. WMI2 + settings + upgrades + related changes. Fixes or implements #103, #477, #496, #597, #599, #621, #626, #631, #634, #641, #642, #647, #657, #658, #659, #660, #671, #674, #676, #685, #687, #700
 * split LMC.configuration into 2 parts:
   * a new `foundations.settings`, which contains roughly the licorn-only parts;
   * `LMC.configuration` is still there and accessed like before, but it contains only `core` and `extension` parameters.
   * some settings (configuration.acls, configuration.users, configuration.groups) are not yet in their definitive location, we need to think a little more about them.

 * create a new `licornd-wmi` daemon, which embeds `Twisted` as web-server, and `django` (+ `jinja2` templating language via `djinja`) as a real `wsgi` application and web framework. This opens up the way for faster WMI development. The new WMI2 is SSL-only, with an autogenerated and self-signed certificate for now.

 * create an `upgrades` facility, to ease system upgrades when installing new licorn versions, as packages or not. The main goal is to ease the package maintenance of Licorn® by moving code into Licorn® and avoid duplicating the work of package maintainers accross Linux distros, and ease developper installations by automating install tasks to the maximum. this `upgrades` facility is the Right Way To Go™ to implement #327, for example. Without this, it would have been a pain.

 * `upgrades`: simplify a lot the installation procedure; install pip, twisted, django, jinja2, djinja, only when needed (on some distros they are packaged, on others not, depending on distro version); setup the Django session database before starting the WMI. Create the `/etc/licorn` configuration directory, remount / or /home with options `acl,user_xattr` and make these options permanent in `/etc/fstab`. This made the installation-from-source documentation much simpler.

 * Makefile additions for new WMI daemon, and developper installation.

 * A new `contrib/dev_install.py` script which does all the dirty job with the final help of the `upgrades` facility. Now it's super-easy to install Licorn®.

 * convert the WMI to a Django project, setup the i18n, make it an ajax full-featured application (with a server-push stream with auto-reconnect, and all the nifty features).

 * implement `licoQnd -K`, which kills everyone (not only the genuine `licornd`, but also the WMI).

 * foundations:
   * clean the `__init__.py`; move most of its contents to ` _options` and `_settings`, and finally define an easy way to import `options` and `settings` from inside and outside the `foundations` (see source code for real-life examples).
   * add a minimal `cache` module, which works à la Django. implemented via a simple dict for now, but speeds up many lenghty operations (compute needed space for next backup, apt status, and the like).
   * add some functions for new functionnalities in the `fsapi` module.
   * start the big testsuite work with `py.test`, and create some tests for the `fsapi` and `packaging` modules. Not complete, this is really a long-lasting work.
   * import the event facilities from the daemon and create the `events` foundations module. Make the whole thing cleaner and more generic than it was, with handlers and callbacks, decorators correctly handling functions and methods.
   * rework `base` and `classes` modules, to refactor some functionnalities and clean up things.
   * remove the `hooks` modules; this is implemented via `events`.
   * import the workers facilities from the daemon and clean it up like the `events` modules.
   * enhance the `process` module with new functionnalities and cleanups.
   * create a `json` modules which wraps the official Python `json` module, with our own specificities transparently added for the `LicornConfigObject` class.
   * remove the old `README`, the doc is now at http://docs.licorn.org/

 * `core`, `extensions`, `daemon` and `foundations`: move `roles` and `priorities` to `foundations.constants`, where they should have belong from the start.

 * `extensions`: create a minimal `Samba3` extension, to pull out samba-related things from the core. This ext does nothing more that what was done before, but make things much cleaner, source-code-wise.

 * `foundations`/`core`: implement a basic APT-related mechanism to be aware about software updates on remote Licorn® machines, and be able to make them upgrade themselves via `unattended-upgrades`. CLI operations are implemented (`get machines` and `mod clients --upgrade`), WMI2 part are underway.

 * `settings.main_configuration_file`: make `licornd.role` become just `role`. This is much more logical when you read the code, and make daemon/core/extensions initialisation simpler, and code easier to understand, IMHO.

 * everywhere: some more l10n strings, some more u''. Still not 100% coverage, but work is progressing.

 * `foundations.settings`: Any part of licornd/WMI can now add its default settings to this singleton object, and check them before using them (not yet an API, but some kind of internal standards).

 * `foundations.ltrace`: small enhancements and bugfixes, most notably in `frame_informations()`.

 * Copyright notices updates in most common places. Some are still missing, but everything comes with the same GPLv2 license, obviously.

 * `core.system` is no more a controller. Regarding what it did until now, it never was. But it was created as such, for Pyro inheritance (which is now manually included) and extensions compatibility (which is not necessary anymore, because extensions can be totally independant of any controller now).

 * the pickle mechanism is more generic and core-wide. Any core (or inherited) class can just inherit from `PicklableObject`, and define a `_lpickle_` class attributes which defines the behaviour of the global `__getstate__` implementation.

 * all core object now benefit from the `super()` python power. This was necessary for the pickle-friendly implementation, and makes the code much more cleaner.

 * `daemon.rwi.select()` can now act on anything implementing the `core.classes.SelectableController` class. This permits selecting `Volume`s and anything interesting, not just `User`s or `Group`s. This permits selecting these kind of objects remotely too (eg. in the WMI), via the Pyro tunnel/pickle facility.

 * WMI / core / daemon: via the Pyro connection, an authorized user can now call virtually anything in the daemon or the core from the outside. This seems scary, but core methods are protected against bad arguments (this is a required feature when writing them), and any pyro-connected user already acts via the RWI, and such special calls can be better protected by decorators (in the RWI or in the core) in the future. The underlying mechanism is more flexible than needing to create a new pyro object. It works for attributes, methods, properties as of now.

 * `cli.get` events: fix the verbose adjusting in the good thread, on the daemon side.

 * `core.controllers.CoreFSController` and `foundations.fsapi`: refactor the `FsapiObject` and `ACLRule` classes in `fsapi`, and clean them a little.

 * `core._objects` : remove a harmless warning in __unwatch_directory() when inotifier is disabled.

 * `get inside` : the history gets saved before trying to close the remote console. This avoids loosing our last commands when debugging and restarting the remote server many times (we get 'connection lost' everytime).

 * `daemon/cli/LMC.connect()`: clean and refactor the Pyro attributes and connections. Now, the WMI and any CLI process only consume ONE network connection (for RWI or system, depending on which type of remote-daemon they connect), instead of 3. Resources saved.




The `LMC.configuration` split, which feels more natural to me, allows much easier initialisation of daemons (master/client/wmi). The required low-level parts (interfaces, ports, etc) are now in `settings`, and there is no more need for LMC connection circonvolutions in the client. Startup procedures are much simpler, and easier to understand. The client daemon doesn't need a connection to any server to start, which is more reliable.


  * create a new `licornd-wmi` daemon, for many reasons:
   * externalize security risks; in a near future, this daemon should run as an unprivileged user.
   * handling the web-related things is not much the role of a master server, this should really be a dedicated thing.
   * not having the needed things in RWI to externalize WMI was not a good enough reason to pull it in the original licornd.
   * `licornd` and `licornd-wmi` are more independant from each other than in the previous forked implementation.
     * `licornd` will start a `licornd-wmi`, if not already started and not disabled by configuration or CLI options.
     * `licornd-wmi` will daemonize, and will try to connect to `licornd` via `Pyro` as soon as possible.
     * if `licornd-wmi` is started alone, it will automatically fork a `licornd` if doesn't find any running.
  * use `Twisted` as web server, which brings a whole new set of possibilities. We now rely on a real web-server implementation, which allows us to :
     * use sessions (whaaaaaa! at last)
     * use form based authentication and abandon the security-bad and small-featured HTTP-basic scheme.
     * use HTTP streaming and javascript long-polling, via `HTTP Transfer-Encoding: chunked` (thanks, `twisted`).
     * don't fear the requests count and parallelism.
     * use any future cool-feature coming in the HTTP world (`WebSockets`? Yeah! TwistedLabs are looking at it; http://twistedmatrix.com/trac/ticket/4173)
  * use `Django`:
     * automate CRSF protection, GET and POST handling
     * automate FORM handling
     * use a templates system everywhere
     * develop faster.
  * use a `WSGI` approach:
     * our applications still embeds Licorn-only features, and the web-server is full of event queues, dedicated threads and live-connections to licornd. This makes the whole experience many times smarter than before. Eg. adding a user with the CLI makes it immediately live-appear in the WMI users list. All other internal events are handled the same.

